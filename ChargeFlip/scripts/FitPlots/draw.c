// Author    : mat@ihep.ac.cn
// Date      : May 13, 2018 
// Descrption: It is used to draw some plots of fitting results perfermed by program ../Fit/fit.c
// Inputs    : txt files generated by programs ../Fit/fit.c and ./get_truth.cxx 
// Outputs   : eps files store at ./plots 
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <vector>
#include <string>
#include <sstream>
#include <cmath>
#include "Rtypes.h"
#include "TCanvas.h"
#include "TLegend.h"
#include "TPaveText.h"
#include "TGraphErrors.h"
#include "TMultiGraph.h"
#include "TStyle.h"
#include "TH2D.h"
#include "TFile.h"

using namespace std;

const double VETAS[] = {0, 0.5, 1, 1.37, 1.52, 1.8, 2.0, 2.47};
const double VPTS[]  = {25, 60, 90, 130, 150, 1000};
const int NETA  = sizeof(VETAS)/sizeof(VETAS[0]) - 1;
const int NPT   = sizeof(VPTS)/sizeof(VPTS[0]) - 1;
const int SIZE  = NETA*NPT;

const int NUM_MC   = 3;  //0:mc fit; 1:mc truth; 2:diff
const int NUM_DATA = 6;  //0-4 for comparsion, 5 for final contribution

double y[SIZE], y_err[SIZE];
double x[SIZE], x_err[SIZE];
void loadvalue(string path);

double data[NUM_DATA][NPT][NETA]; 
double data_err[NUM_DATA][NPT][NETA];
double mc[NUM_MC][NPT][NETA];     
double mc_err[NUM_MC][NPT][NETA];

double diff[NPT][NETA];      //the max deviations from fitted values

void cal_sys(double m, double dm, double t, double dt, double &sys, double &sys_err);
void DrawDataMC(TCanvas *c, 
		TGraphErrors *g_data, 
		TGraphErrors *g_mc, 
		TGraphErrors *g_sys,
		TLegend      *leg,
		string x_title,
		string y_title,
		string z_title,
		string leg_title,
		string leg_entry_1,
		string leg_entry_2,
		string leg_format_1 = "lep",
		string leg_format_2 = "lep");
double getMax(TGraphErrors *gr);
double getMin(TGraphErrors *gr);
void   SetStyle();

int draw()
{
	SetStyle();

	vector<string> path_data;
	path_data.clear();
	path_data.push_back( "../Fit/fit_data_signal_80_100_20_20.txt" );
	path_data.push_back( "../Fit/fit_data_signal_80_100_15_15.txt" );
	path_data.push_back( "../Fit/fit_data_signal_80_100_25_25.txt" );
	path_data.push_back( "../Fit/fit_data_signal_75_105_20_20.txt" );
	path_data.push_back( "../Fit/fit_data_signal_80_100_0_0.txt" );

	vector<EColor> color_data;
	color_data.clear();
	color_data.push_back( kBlack );
	color_data.push_back( kBlue  );
	color_data.push_back( kRed   );
	color_data.push_back( kGreen );
	color_data.push_back( kPink );

	vector<string> path_mc;
	path_mc.clear();
	path_mc.push_back( "../Fit/fit_mc_signal_80_100_0_0.txt" );
	path_mc.push_back( "./mc_signal_truth.txt" );

	vector<EColor> color_mc;
	color_mc.clear();
	color_mc.push_back( kBlue );
	color_mc.push_back( kRed  );

	for (unsigned int i = 0; i < NETA; i++)
	{
		x[i]     = (VETAS[i+1] + VETAS[i])/ 2. ;
		x_err[i] = (VETAS[i+1] - VETAS[i])/ 2. ;
	}

	TGraphErrors *gd_mc[NUM_MC][NPT];
	TGraphErrors *gd_data[NUM_DATA][NPT];

	// load mc, mc_truth
	for (unsigned int n = 0; n < path_mc.size(); n++)
	{
		loadvalue(path_mc[n]);
		for (unsigned int i = 0; i < NPT; i++)
		{
			for (unsigned int j = 0; j < NETA; j++)
			{
				int k = j * NPT + i;
				mc[n][i][j]     = y[k];
				mc_err[n][i][j] = y_err[k];
			}
		}
		for (unsigned int i = 0; i < NPT; i++)
		{
			gd_mc[n][i] = new TGraphErrors(NETA);
			gd_mc[n][i]->SetMarkerColor(color_mc[n]);
			gd_mc[n][i]->SetMarkerStyle(21+n);
			gd_mc[n][i]->SetMarkerSize(1.6);
			gd_mc[n][i]->SetLineWidth(2);
			for (unsigned int j = 0; j < NETA; j++)
			{
				gd_mc[n][i]->SetPoint(j, x[j], mc[n][i][j]);
				gd_mc[n][i]->SetPointError(j, x_err[j], mc_err[n][i][j]);
			}
		}
	}
	// calculate the difference between mc and mc_truth
	for (unsigned int i = 0; i < NPT; i++)
	{
		gd_mc[NUM_MC-1][i] = new TGraphErrors(NETA);
		gd_mc[NUM_MC-1][i]->SetMarkerColor( kBlack );
		gd_mc[NUM_MC-1][i]->SetMarkerStyle( 20 );
		gd_mc[NUM_MC-1][i]->SetMarkerSize(1.6);
		gd_mc[NUM_MC-1][i]->SetLineWidth(2);
		for (unsigned int j = 0; j < NETA; j++)
		{
			cal_sys(mc[0][i][j], mc_err[0][i][j], mc[1][i][j], mc_err[1][i][j], mc[2][i][j], mc_err[2][i][j]);
			gd_mc[NUM_MC-1][i]->SetPoint(j, x[j], mc[2][i][j]);
			gd_mc[NUM_MC-1][i]->SetPointError(j, x_err[j], mc_err[2][i][j]);
		}
	}

	// load data for comparison
	for (unsigned int n = 0; n < path_data.size(); n++)
	{
		loadvalue(path_data[n]);
		for (unsigned int i = 0; i < NPT; i++)
		{
			for (unsigned int j = 0; j < NETA; j++)
			{
				if (n == 0)
				{
					diff[i][j] = -1;  //initialization
				}
				int k = j * NPT + i;
				data[n][i][j]     = y[k];
				data_err[n][i][j] = y_err[k];
				double delta = std::fabs(data[n][i][j] - data[0][i][j]);
				if (delta > diff[i][j])
				{
					diff[i][j] = delta;
				}
			}
		}
		for (unsigned int i = 0; i < NPT; i++)
		{
			gd_data[n][i] = new TGraphErrors(NETA);
			gd_data[n][i]->SetMarkerColor( color_data[n] );
			gd_data[n][i]->SetMarkerStyle( 20+n );
			gd_data[n][i]->SetMarkerSize(1.2);
			for (unsigned int j = 0; j < NETA; j++)
			{
				gd_data[n][i]->SetPoint(j, x[j], data[n][i][j]);
				gd_data[n][i]->SetPointError(j, x_err[j], data_err[n][i][j]);
			}
		}
	}
	for (unsigned int i = 0; i < NPT; i++)
	{
		gd_data[NUM_DATA - 1][i] = new TGraphErrors(NETA);
		gd_data[NUM_DATA - 1][i]->SetMarkerColor( kBlue );
		gd_data[NUM_DATA - 1][i]->SetMarkerStyle( 20 );
		gd_data[NUM_DATA - 1][i]->SetMarkerSize(1.2);
		for (unsigned int j = 0; j < NETA; j++)
		{
			data[NUM_DATA-1][i][j] = data[0][i][j];
			// only sys.
			data_err[NUM_DATA-1][i][j] = diff[i][j]*diff[i][j] + (mc[0][i][j] - mc[1][i][j])*(mc[0][i][j] - mc[1][i][j]);
			data_err[NUM_DATA-1][i][j] = std::sqrt( data_err[NUM_DATA-1][i][j] );
			gd_data[NUM_DATA - 1][i]->SetPoint(j, x[j], data[NUM_DATA-1][i][j]);
			gd_data[NUM_DATA - 1][i]->SetPointError(j, x_err[j], data_err[NUM_DATA-1][i][j]);
		}
	}

	// data charge-flip rate 2d plot
	TH2D *h_data_rate     = new TH2D("hFlipProb_data", "hFlipProb_data", NPT, VPTS, NETA, VETAS);
	TH2D *h_data_rate_sys = new TH2D("hFlipProb_data_sys", "hFlipProb_data", NPT, VPTS, NETA, VETAS);
	for (unsigned int i = 0; i < NPT; i++)
	{
		for (unsigned int j = 0; j < NETA; j++)
		{
			h_data_rate->SetBinContent(i+1, j+1, data[0][i][j] * 1000.);
			h_data_rate->SetBinError(i+1, j+1, data_err[0][i][j] * 1000.);
			h_data_rate_sys->SetBinContent(i+1, j+1, data[NUM_DATA-1][i][j] * 1000.);
			h_data_rate_sys->SetBinError(i+1, j+1, data_err[NUM_DATA-1][i][j] * 1000.);
		}
	}
	h_data_rate->GetXaxis()->SetTitle("p_{T} (GeV)");
	h_data_rate->GetXaxis()->CenterTitle();
	h_data_rate->GetXaxis()->SetTitleOffset(1.0);;
	h_data_rate->GetYaxis()->SetTitle("|#eta|");
	h_data_rate->GetYaxis()->CenterTitle();
	h_data_rate->GetYaxis()->SetTitleOffset(1.1);;
	h_data_rate_sys->GetXaxis()->SetTitle("p_{T} (GeV)");
	h_data_rate_sys->GetXaxis()->CenterTitle();
	h_data_rate_sys->GetXaxis()->SetTitleOffset(1.0);;
	h_data_rate_sys->GetYaxis()->SetTitle("|#eta|");
	h_data_rate_sys->GetYaxis()->CenterTitle();
	h_data_rate_sys->GetYaxis()->SetTitleOffset(1.1);;


	gStyle->SetPadRightMargin(0.15);
	gStyle->SetPadLeftMargin(0.20);
	gStyle->SetPadTopMargin(0.10);
	gStyle->SetTitleOffset(0.1, "y");
	gStyle->SetPaintTextFormat("4.2f");

	TCanvas *c1 = new TCanvas("c1", "c1", 900, 900);
	c1->SetLogx();
	h_data_rate->Draw("TEXT45E, COLZ");
	TPaveText *pt = new TPaveText(0.32, 0.91, 0.70, 0.96, "blNDC");
	pt->SetBorderSize(0);
	pt->SetFillColor(0);
	pt->SetFillStyle(0);
	pt->SetTextFont(42);
	pt->AddText("Rate from likelihood (#times10^{-3}) (stat.)");
	pt->Draw();
	c1->Modified();
	c1->SaveAs("./plots/data_cf_rate_stat.eps");

	TCanvas *c2 = new TCanvas("c2", "c2", 900, 900);
	c2->SetLogx();
	h_data_rate_sys->Draw("TEXT45E, COLZ");
	pt = new TPaveText(0.32, 0.91, 0.70, 0.96, "blNDC");
	pt->SetBorderSize(0);
	pt->SetFillColor(0);
	pt->SetFillStyle(0);
	pt->SetTextFont(42);
	pt->AddText("Rate from likelihood (#times10^{-3}) (sys.)");
	pt->Draw();
	c2->Modified();
	c2->SaveAs("./plots/data_cf_rate_sys.eps");

	gStyle->SetPadRightMargin(0.05);
	gStyle->SetPadTopMargin(0.05);
	gStyle->SetTitleOffset(1.6, "y");
	gStyle->SetPadLeftMargin(0.23);

	// draw comparison between MC fit and MC truth (validation)
	TCanvas *c[NPT];
	for (unsigned int i = 0; i < NPT; i++)
	{
		TLegend *leg = new TLegend(0.25, 0.70, 0.55,0.85);
		c[i] = new TCanvas(Form("c_%d", i), "canvas", 900, 900);
		string label = Form("%d < #font[52]{p}_{T} < %d GeV", (int)VPTS[i], (int)VPTS[i+1]);
		DrawDataMC(c[i], gd_mc[0][i], gd_mc[1][i], gd_mc[2][i], leg, "|#eta|", "Charge-flip Rate", "#frac{#epsilon_{charge flip}^{MC}}{#epsilon_{charge flip}^{MC Truth}}", label, "MC Fit", "MC Truth"); 
		c[i]->SaveAs( Form("./plots/mc_cf_rate_%d.eps", i) );
	}


	TCanvas *c3[NPT];
	TMultiGraph *mg[NPT];
	for (unsigned int i = 0; i < NPT; i++)
	{
		c3[i] = new TCanvas(Form("c3_%d", i), "c", 900, 900);
		gPad->SetLogy();
		mg[i] = new TMultiGraph();
		mg[i]->Add(gd_data[0][i], "");
		mg[i]->Add(gd_data[1][i], "");
		mg[i]->Add(gd_data[2][i], "");
		mg[i]->Add(gd_data[3][i], "");
		mg[i]->Add(gd_data[4][i], "");
		mg[i]->Draw("AP");
		mg[i]->GetXaxis()->SetTitle("|#eta|");
		mg[i]->GetXaxis()->CenterTitle();
		mg[i]->GetYaxis()->SetTitle("Charge-flip rate");
		mg[i]->GetYaxis()->CenterTitle();
		mg[i]->GetYaxis()->SetRangeUser(0.9 * mg[i]->GetHistogram()->GetMinimum(), 2.0 * mg[i]->GetHistogram()->GetMaximum());
		string label = Form("%d < #font[52]{p}_{T} < %d GeV", (int)VPTS[i], (int)VPTS[i+1]);
		TLegend *leg = new TLegend(0.25, 0.73, 0.70, 0.88);
		// supported in root v6.10
		//leg->SetHeader(label.c_str(), "c");
		leg->SetHeader(label.c_str());
		leg->SetTextFont(42);
		leg->SetTextSize(0.030);
		leg->AddEntry((TObject*)0, "", "");
		leg->AddEntry((TObject*)0, "", "");
		leg->AddEntry(gd_data[0][i], "SR:80-100 GeV, SB:20 GeV",   "lep");
		leg->AddEntry((TObject*)0, "", "");
		leg->AddEntry(gd_data[1][i], "SR:80-100 GeV, SB:15 GeV",   "lep");
		leg->AddEntry((TObject*)0, "", "");
		leg->AddEntry(gd_data[2][i], "SR:80-100 GeV, SB:25 GeV",   "lep");
		leg->AddEntry((TObject*)0, "", "");
		leg->AddEntry(gd_data[3][i], "SR:75-105 GeV, SB:20 GeV",   "lep");
		leg->AddEntry((TObject*)0, "", "");
		leg->AddEntry(gd_data[4][i], "SR:80-100 GeV, SB:0 GeV",   "lep");
		leg->Draw();
		c3[i]->Update();	
		c3[i]->SaveAs(Form("./plots/data_cf_comparison_%d.eps", i));
	}

	TCanvas *c4 = new TCanvas("c4", "c4", 1200, 800);
	c4->Divide(3, 2);
	for (unsigned int i = 0; i < NPT; i++)
	{
		c4->cd(i+1);
		gd_data[0][i]->Draw("AP");
		gd_data[0][i]->GetXaxis()->SetTitle("|#eta|");
		gd_data[0][i]->GetXaxis()->CenterTitle();
		gd_data[0][i]->GetYaxis()->SetTitle("Charge flip rate");
		gd_data[0][i]->GetYaxis()->CenterTitle();
		string label = Form("%d < #font[52]{p}_{T} < %d GeV", (int)VPTS[i], (int)VPTS[i+1]);
		TLegend *leg = new TLegend(0.25, 0.70, 0.55, 0.85);
		leg->SetHeader(label.c_str());
		leg->SetTextFont(42);
		leg->SetTextSize(0.05);
		leg->AddEntry(gd_data[0][i], "Data Fit",   "lep");
		leg->Draw();
		c4->Update();	
	}
	c4->SaveAs("./plots/data_cf.eps");

	return 0;
}

void loadvalue(string path)
{
	ifstream in(path.c_str());
	if (in.is_open())
	{
		string line;
		unsigned int i = 0;
		while(getline(in, line))
		{
			stringstream ss(line);
			ss >> y[i] >> y_err[i];
			i++;
		}
	}
	else
	{
		cerr << "Cannot open file : " << path << endl;
		exit(1);
	}
}

void cal_sys(double m, double dm, double t, double dt, double &sys, double &sys_err)
{
	double item = m / t;
	sys = item;
	double a = dm / m;
	double b = dt / t;
	double c = std::sqrt(a*a + b*b);
	sys_err  = c * item;
}

void DrawDataMC(TCanvas *c, 
		TGraphErrors *g_data, 
		TGraphErrors *g_mc, 
		TGraphErrors *g_sys,
		TLegend      *leg,
		string x_title,
		string y_title,
		string z_title,
		string leg_title,
		string leg_entry_1,
		string leg_entry_2,
		string leg_format_1,
		string leg_format_2)
{
	char pad_name[100];
	sprintf(pad_name, "%s_%d", c->GetName(), 0);

	double size = 0.25;

	TPad *pad_1 = new TPad(pad_name,"This is pad1", 0.0, size, 1, 1);
	sprintf(pad_name, "%s_%d", c->GetName(), 1);
	TPad *pad_2 = new TPad(pad_name,"This is pad2", 0.0, 0.0, 1, size);

	pad_1->SetFillColor(0);
	pad_1->SetLeftMargin(0.23);
	pad_1->SetBottomMargin(0.17);
	pad_2->SetFillColor(0);
	pad_2->SetLeftMargin(0.23);
	pad_2->SetBottomMargin(0.17);
	pad_1->Draw();
	pad_2->Draw();

	pad_1->cd();
	pad_1->SetLogy();
	TMultiGraph *mg_1 = new TMultiGraph();
	mg_1->Add(g_data, "");
	mg_1->Add(g_mc, "");
	mg_1->Draw("AP");

	double x_label_size = mg_1->GetXaxis()->GetLabelSize();
	double y_label_size = mg_1->GetYaxis()->GetLabelSize();
	mg_1->GetXaxis()->SetTitle( x_title.c_str() );
	mg_1->GetXaxis()->CenterTitle();
	mg_1->GetYaxis()->SetTitle( y_title.c_str() );
	mg_1->GetYaxis()->CenterTitle();
	mg_1->GetYaxis()->SetRangeUser(0.8 * mg_1->GetHistogram()->GetMinimum(), 2.0 * mg_1->GetHistogram()->GetMaximum());
	double x_tick_length = mg_1->GetXaxis()->GetTickLength();
	double font_size = mg_1->GetYaxis()->GetTitleSize();
	leg->SetHeader(leg_title.c_str());
	leg->SetTextFont(42);
	leg->SetTextSize(0.05);
	leg->AddEntry((TObject*)0, "", "");
	leg->AddEntry((TObject*)0, "", "");
	leg->AddEntry(g_data, leg_entry_1.c_str(), leg_format_1.c_str());
	leg->AddEntry((TObject*)0, "", "");
	leg->AddEntry(g_mc,   leg_entry_2.c_str(), leg_format_2.c_str());
	leg->Draw();
	pad_1->Update();

	pad_2->cd();
	pad_2->SetGridy();
	TMultiGraph *mg_2 = new TMultiGraph();
	mg_2->Add(g_sys);
	mg_2->Draw("AP");
	mg_2->GetYaxis()->SetTitle( z_title.c_str() );
	mg_2->GetYaxis()->CenterTitle();
	mg_2->GetYaxis()->SetTitleSize( font_size * (1-size) / size * 0.8 );
	mg_2->GetYaxis()->SetTitleOffset( 0.4 );
	mg_2->GetYaxis()->SetRangeUser(0.0, 2.8);
	mg_2->GetYaxis()->SetNdivisions(505);
	mg_2->GetXaxis()->SetLabelSize( x_label_size * (1-size) / size );
	mg_2->GetYaxis()->SetLabelSize( y_label_size * (1-size) / size );
	mg_2->GetXaxis()->SetTickLength( x_tick_length * (1-size) / size );

	pad_2->Update();
}

double getMax(TGraphErrors *gr)
{
	int np = gr->GetN();
	double max = -999999;
	for (unsigned int i = 0; i < np; i++)
	{
		double x, y;
		gr->GetPoint(i, x, y);
		if (y > max)
		{
			max = y;
		}
	}
	return max;
}

double getMin(TGraphErrors *gr)
{
	int np = gr->GetN();
	double min = 999999;
	for (unsigned int i = 0; i < np; i++)
	{
		double x, y;
		gr->GetPoint(i, x, y);
		if (y < min)
		{
			min = y;
		}
	}
	return min;
}

void SetStyle()
{
	gStyle->SetOptStat(kFALSE);
	// No Canvas Border
	gStyle->SetCanvasBorderMode(0);
	gStyle->SetCanvasBorderSize(0);
	// White BG
	gStyle->SetCanvasColor(10);
	// Format for axes
	gStyle->SetLabelFont(42,"xyz");
	gStyle->SetLabelSize(0.05,"xyz");
	gStyle->SetLabelOffset(0.01,"xyz");
	gStyle->SetNdivisions(510,"xyz");
	gStyle->SetTitleFont(42,"xyz");
	gStyle->SetTitleColor(1,"xyz");
	gStyle->SetTitleSize(0.07,"xyz");
	gStyle->SetTitleOffset(1.0,"x");
	gStyle->SetTitleOffset(1.6,"y");
	//gStyle->SetTitleOffset(1.15,"xyz");
	// No pad borders
	gStyle->SetPadBorderMode(0);
	gStyle->SetPadBorderSize(0);
	// White BG
	gStyle->SetPadColor(10);
	// Margins for labels etc.
	gStyle->SetPadLeftMargin(0.23);
	gStyle->SetPadRightMargin(0.05);
	//gStyle->SetPadRightMargin(0.15);
	gStyle->SetPadBottomMargin(0.15);
	gStyle->SetPadTopMargin(0.05);
	// No error bars in x direction
	gStyle->SetErrorX(0);
	// Format legend
	gStyle->SetLegendBorderSize(0);
	gStyle->SetOptTitle(0);
	//gStyle->SetEndErrorSize(0);
	gROOT->ForceStyle();
}
