// Author    : mat@ihep.ac.cn
// Date      : May 13, 2018 
// Descrption: It is used to encapsulate the fitted results into a ROOT file  
// Inputs    : txt files generated by programs ../Fit/fit.c and ../FitPlots/get_truth.cxx
// Outputs   : cfRatesSignal.root 
#include <iostream>
#include <fstream>
#include <cstdlib>
#include <vector>
#include <string>
#include <sstream>
#include <cmath>
#include "Rtypes.h"
#include "TCanvas.h"
#include "TLegend.h"
#include "TPaveText.h"
#include "TGraphErrors.h"
#include "TMultiGraph.h"
#include "TStyle.h"
#include "TH2D.h"
#include "TFile.h"
#include "TROOT.h"

using namespace std;

const double VETAS[] = {0, 0.5, 1, 1.37, 1.52, 1.8, 2.0, 2.47};
const double VPTS[]  = {25, 60, 90, 130, 150, 1000};
const int NETA  = sizeof(VETAS)/sizeof(VETAS[0]) - 1;
const int NPT   = sizeof(VPTS)/sizeof(VPTS[0]) - 1;
const int SIZE  = NETA*NPT;

const int NUM_MC   = 2;  //0:mc fit; 1:mc truth; 2:diff
const int NUM_DATA = 7;  //0-4 for comparsion, 5 for sys, 6 for sys.+stat.

double y[SIZE], y_err[SIZE];
double x[SIZE], x_err[SIZE];
void loadvalue(string path);

double data[NUM_DATA][NPT][NETA]; 
double data_err[NUM_DATA][NPT][NETA];
double mc[NUM_MC][NPT][NETA];     
double mc_err[NUM_MC][NPT][NETA];

double diff[NPT][NETA];      //the max deviations from fitted values

void SetStatus(TH2D *h);

int gen_signal()
{
	TFile *f = new TFile("cfRatesSignal.root", "RECREATE");
	vector<string> path_data;
	path_data.clear();
	path_data.push_back( "../Fit/fit_data_signal_80_100_20_20.txt" );
	path_data.push_back( "../Fit/fit_data_signal_80_100_15_15.txt" );
	path_data.push_back( "../Fit/fit_data_signal_80_100_25_25.txt" );
	path_data.push_back( "../Fit/fit_data_signal_75_105_20_20.txt" );
	path_data.push_back( "../Fit/fit_data_signal_80_100_0_0.txt" );

	vector<EColor> color_data;
	color_data.clear();
	color_data.push_back( kBlack );
	color_data.push_back( kBlue  );
	color_data.push_back( kRed   );
	color_data.push_back( kGreen );
	color_data.push_back( kPink );

	vector<string> path_mc;
	path_mc.clear();
	path_mc.push_back( "../Fit/fit_mc_signal_80_100_0_0.txt" );
	path_mc.push_back( "../FitPlots/mc_signal_truth.txt" );

	vector<EColor> color_mc;
	color_mc.clear();
	color_mc.push_back( kBlue );
	color_mc.push_back( kRed  );

	for (unsigned int i = 0; i < NETA; i++)
	{
		x[i]     = (VETAS[i+1] + VETAS[i])/ 2. ;
		x_err[i] = (VETAS[i+1] - VETAS[i])/ 2. ;
	}

	// load mc, mc_truth
	for (unsigned int n = 0; n < path_mc.size(); n++)
	{
		loadvalue(path_mc[n]);
		for (unsigned int i = 0; i < NPT; i++)
		{
			for (unsigned int j = 0; j < NETA; j++)
			{
				int k = j * NPT + i;
				mc[n][i][j]     = y[k];
				mc_err[n][i][j] = y_err[k];
			}
		}
	}

	// load data for comparison
	for (unsigned int n = 0; n < path_data.size(); n++)
	{
		loadvalue(path_data[n]);
		for (unsigned int i = 0; i < NPT; i++)
		{
			for (unsigned int j = 0; j < NETA; j++)
			{
				if (n == 0)
				{
					diff[i][j] = -1;  //initialization
				}
				int k = j * NPT + i;
				data[n][i][j]     = y[k];
				data_err[n][i][j] = y_err[k];
				double delta = std::fabs(data[n][i][j] - data[0][i][j]);
				if (delta > diff[i][j])
				{
					diff[i][j] = delta;
				}
			}
		}
	}
	for (unsigned int i = 0; i < NPT; i++)
	{
		for (unsigned int j = 0; j < NETA; j++)
		{
			// only sys.
			data[NUM_DATA-2][i][j] = data[0][i][j];
			double MCTruthError = (mc[0][i][j] - mc[1][i][j]) /mc[0][i][j] *data[0][i][j];
			data_err[NUM_DATA-2][i][j] = diff[i][j]*diff[i][j] + MCTruthError*MCTruthError;
			data_err[NUM_DATA-2][i][j] = std::sqrt( data_err[NUM_DATA-2][i][j] );
			// sys. + stat.
			data[NUM_DATA-1][i][j] = data[0][i][j];
			data_err[NUM_DATA-1][i][j] = data_err[0][i][j]*data_err[0][i][j] + diff[i][j]*diff[i][j] + MCTruthError*MCTruthError;
			data_err[NUM_DATA-1][i][j] = std::sqrt( data_err[NUM_DATA-1][i][j] );
		}
	}

	// data charge-flip rate 2d plot
	TH2D *h_data     = new TH2D("hFlipProb_data", "h", NPT, VPTS, NETA, VETAS);
	TH2D *h_data_sys = new TH2D("hFlipProb_AllSys", "h", NPT, VPTS, NETA, VETAS);
	TH2D *h_data_tot = new TH2D("hFlipProb_SysAndStat", "h", NPT, VPTS, NETA, VETAS);
	TH2D *h_mc       = new TH2D("hFlipProb_MCLH", "h", NPT, VPTS, NETA, VETAS);
	TH2D *h_mc_truth = new TH2D("hFlipProb_MCtruth", "h", NPT, VPTS, NETA, VETAS);

	for (unsigned int i = 0; i < NPT; i++)
	{
		for (unsigned int j = 0; j < NETA; j++)
		{
			h_data->SetBinContent(i+1, j+1, data[0][i][j]);
			h_data->SetBinError(i+1, j+1, data_err[0][i][j]);
			h_data_sys->SetBinContent(i+1, j+1, data[NUM_DATA-2][i][j]);
			h_data_sys->SetBinError(i+1, j+1, data_err[NUM_DATA-2][i][j]);
			h_data_tot->SetBinContent(i+1, j+1, data[NUM_DATA-1][i][j]);
			h_data_tot->SetBinError(i+1, j+1, data_err[NUM_DATA-1][i][j]);
			h_mc->SetBinContent(i+1, j+1, mc[0][i][j]);
			h_mc->SetBinError(i+1, j+1, mc_err[0][i][j]);
			h_mc_truth->SetBinContent(i+1, j+1, mc[1][i][j]);
			h_mc_truth->SetBinError(i+1, j+1, mc_err[1][i][j]);
		}
	}
	SetStatus(h_data);
	SetStatus(h_data_sys);
	SetStatus(h_data_tot);
	SetStatus(h_mc);
	SetStatus(h_mc_truth);

	gStyle->SetPadRightMargin(0.15);
	gStyle->SetPadLeftMargin(0.20);
	gStyle->SetPadTopMargin(0.10);
	gStyle->SetTitleOffset(0.1, "y");
	gStyle->SetPaintTextFormat("4.2f");
	gROOT->ForceStyle();

	f->Close();

	return 0;
}

void SetStatus(TH2D *h)
{
	h->GetXaxis()->SetTitle("p_{T} (GeV)");
	h->GetXaxis()->CenterTitle();
	h->GetXaxis()->SetTitleOffset(1.0);;
	h->GetYaxis()->SetTitle("|#eta|");
	h->GetYaxis()->CenterTitle();
	h->GetYaxis()->SetTitleOffset(1.1);;
	h->Write();
}


void loadvalue(string path)
{
	ifstream in(path.c_str());
	if (in.is_open())
	{
		string line;
		unsigned int i = 0;
		while(getline(in, line))
		{
			stringstream ss(line);
			ss >> y[i] >> y_err[i];
			i++;
		}
	}
	else
	{
		cerr << "Cannot open file : " << path << endl;
		exit(1);
	}
}

